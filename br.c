/*
Создаем массив 20х20 для рисования
*/
#include <stdio.h>
#include <stdlib.h>
#define MAXX 20
#define MAXY 20
char data[MAXX][MAXY];

/*
Функция для рисования точки с координатами x,y, которую
я буду использовать.
*/
inline void paint(int x, int y, char c){
  if ((x<0)||(x>MAXX)||(y<0)||(y>MAXY)){
    printf("Range error: %d, %d", x,y);
    exit(1);
  }
  data[x][y] = c;
  return;
}

/*
Алгоритм Брезенхема для рисования линий.

Пусть у нас есть плоскость с целочисленными координатами и нам надо
нарисовать на ней что-то похожее на отрезок прямой линии от точки (x, y)
до точки (x+dx, y+dy).

Пусть для начала dx>dy>0. (Для рисования произвольных отрезков нам
потом придется рассматривать и другие случаи.)

Нам нужно чередовать одиночные шаги по оси y с последовательностями из
нескольких шагов по оси x.

Введем параметр e, отклонение от правильной прямой. В начале оно
равно нулю, когда мы делаем шаг по оси x оно увеличивается на dy/dx.
Если следующий шаг по x приведет к тому, что отклонение перевалит за 1/2,
то перед ним делаем шаг по оси y и вычитаем из отклонения 1. Продолжаем,
пока не дойдем до нужной точки.

Чтобы работать только с целыми числами, будем всегда умножать
отклонение на 2*dx. То есть, при смещении по x будем добавлять к отклонению
2*dy, а при достижении им величины dx вычтем из него 2*dx и сделаем шаг по y.
*/

void line1(int x1, int y1, int x2, int y2){
  int dx=x2-x1, dy=y2-y1;
  int e=0;

  paint(x1,y1,'F');
  while (x1<=x2){
    /* если шаг по x не приведет к большому отклонению, сделаем шаг по оси x */
    if (e+2*dy<dx){
      x1++;
      e+=2*dy;
      paint(x1,y1,'X');
    }
    /* иначе - шаг по оси y */
    else {
      y1++;
      e-=2*dx;
    }
  }
}

/* Результат  line1(1,1,17,13);
. . . . . . . . . . . . . . . . . . . .
. F . . . . . . . . . . . . . . . . . .
. . X . . . . . . . . . . . . . . . . .
. . . X X . . . . . . . . . . . . . . .
. . . . . X . . . . . . . . . . . . . .
. . . . . . X . . . . . . . . . . . . .
. . . . . . . X X . . . . . . . . . . .
. . . . . . . . . X . . . . . . . . . .
. . . . . . . . . . X . . . . . . . . .
. . . . . . . . . . . X X . . . . . . .
. . . . . . . . . . . . . X . . . . . .
. . . . . . . . . . . . . . X . . . . .
. . . . . . . . . . . . . . . X X . . .
. . . . . . . . . . . . . . . . . X . .
. . . . . . . . . . . . . . . . . . X .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
*/

/*
Маленькие оптимизации:
 - к отклонению сразу добавим 2*dy-dx и будем сравнивать его с 0
 - умножение на 2 заменим сдвигом

У меня первая оптимизация увеличивает скорость в 4.8 раза
(без учета записи точки, для dx/dy = ~10), а вторая не
влияет на скорость (компилятор умный?).
*/

void line2(int x1, int y1, int x2, int y2){
  int dx=x2-x1, dy=y2-y1;
  int e=(dy<<1)-dx;

  paint(x1,y1,'F');
  while (x1<=x2){
    if (e<0){
      x1++;
      e+=dy<<1;
      paint(x1,y1,'X');
    }
    else {
      y1++;
      e-=dx<<1;
    }
  }
}

/*
Теперь научусь рисовать отрезки с dy>dx>0
Тут мне кажется удобным просто выделить два случая:
*/

void line3(int x1, int y1, int x2, int y2){
  int dx=x2-x1, dy=y2-y1;
  int e;
  int s=dx>dy;

  paint(x1,y1,'F');
  if (s){
    e = (dy<<1)-dx;
    while (x1!=x2){
      if (e<0){
        x1++; e+=dy<<1;
        paint(x1,y1,'X');
      }
      else {
        y1++; e-=dx<<1;
      }
    }
  }
  else {
    e = (dx<<1)-dy;
    while (y1!=y2){
      if (e<0){
        y1++; e+=dx<<1;
        paint(x1,y1,'Y');
      }
      else {
        x1++; e-=dy<<1;
      }
    }
  }
}

/*
  line3(1,1,17,11);
  line3(1,4,7,18);
. . . . . . . . . . . . . . . . . . . .
. F . . . . . . . . . . . . . . . . . .
. . X X . . . . . . . . . . . . . . . .
. . . . X . . . . . . . . . . . . . . .
. F . . . X X . . . . . . . . . . . . .
. Y . . . . . X X . . . . . . . . . . .
. . Y . . . . . . X . . . . . . . . . .
. . Y . . . . . . . X X . . . . . . . .
. . . Y . . . . . . . . X . . . . . . .
. . . Y . . . . . . . . . X X . . . . .
. . . . Y . . . . . . . . . . X X . . .
. . . . Y . . . . . . . . . . . . X . .
. . . . Y . . . . . . . . . . . . . . .
. . . . . Y . . . . . . . . . . . . . .
. . . . . Y . . . . . . . . . . . . . .
. . . . . . Y . . . . . . . . . . . . .
. . . . . . Y . . . . . . . . . . . . .
. . . . . . . Y . . . . . . . . . . . .
. . . . . . . Y . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
*/

/*
Теперь научусь рисовать отрезки с dy<0 и dx<0
Шаги делаю в нужную сторону, а отклонение считаю,
как если бы все было положительным...
*/

void line4(int x1, int y1, int x2, int y2){
  int dx=x2-x1, dy=y2-y1;
  int e;
  int sx=dx>0;
  int sy=dy>0;

  if (!sx) dx=-dx;
  if (!sy) dy=-dy;

  int s=dx>dy;

  paint(x1,y1,'F');
  if (s){
    e = (dy<<1)-dx;
    while (x1!=x2){
      if (e<0){
        sx?x1++:x1--; e+=dy<<1;
        paint(x1,y1,'X');
      }
      else {
        sy?y1++:y1--; e-=dx<<1;
      }
    }
  }
  else {
    e = (dx<<1)-dy;
    while (y1!=y2){
      if (e<0){
        sy?y1++:y1--; e+=dx<<1;
        paint(x1,y1,'Y');
      }
      else {
        sx?x1++:x1--; e-=dy<<1;
      }
    }
  }
}

/*
  line4(7,5,5,1);
  line4(5,5,1,3);
  line4(18,1,2,11);
  line4(18,4,6,18);
. . . . . . . . . . . . . . . . . . . .
. . . . . Y . . . . . . . . . . . . F .
. . . . . Y . . . . . . . . . . X X . .
. X X . . . Y . . . . . . . . X . . . .
. . . X X . Y . . . . . . X X . . . F .
. . . . . F . F . . . X X . . . . Y . .
. . . . . . . . . . X . . . . . Y . . .
. . . . . . . . X X . . . . . Y . . . .
. . . . . . . X . . . . . . . Y . . . .
. . . . . X X . . . . . . . Y . . . . .
. . . X X . . . . . . . . Y . . . . . .
. . X . . . . . . . . . Y . . . . . . .
. . . . . . . . . . . Y . . . . . . . .
. . . . . . . . . . Y . . . . . . . . .
. . . . . . . . . Y . . . . . . . . . .
. . . . . . . . . Y . . . . . . . . . .
. . . . . . . . Y . . . . . . . . . . .
. . . . . . . Y . . . . . . . . . . . .
. . . . . . Y . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
*/

/*
Теперь рисую линию некоторой ширины w. Это простой способ, при котором
концы получаются не слишком аккуратными. Отличие только в вызове
функции рисования точки: вместо одной точки рисуем полоску нужной
длины, горизонтальную, если dy>dx и вертикальную, если наоборот.

Аккуратные концы и изгибы линий не осилили и в X написать :)
https://bugs.freedesktop.org/show_bug.cgi?id=15946
*/

void line5(int x1, int y1, int x2, int y2, int w){
  int dx=x2-x1, dy=y2-y1;
  int e,j;
  int sx=dx>0;
  int sy=dy>0;

  if (!sx) dx=-dx;
  if (!sy) dy=-dy;

  int s=dx>dy;

  /* разобьем толщину на две примерно равные части:*/
  int w1=w>>1;
  int w2=w>>1;
  if (w1+w2<w) w2++;

  if (s){
    for (j=-w1;j<w2;j++) paint(x1,y1+j,'F');
    e = (dy<<1)-dx;
    while (x1!=x2){
      if (e<0){
        sx?x1++:x1--; e+=dy<<1;
        for (j=-w1;j<w2;j++) paint(x1,y1+j,'X');
      }
      else {
        sy?y1++:y1--; e-=dx<<1;
      }
    }
  }
  else {
    for (j=-w1;j<w2;j++) paint(x1+j,y1,'F');
    e = (dx<<1)-dy;
    while (y1!=y2){
      if (e<0){
        sy?y1++:y1--; e+=dx<<1;
        for (j=-w1;j<w2;j++) paint(x1+j,y1,'Y');
      }
      else {
        sx?x1++:x1--; e-=dy<<1;
      }
    }
  }
}

/*
  line5(5,5,18,9, 3);
  line5(10,18,3,9, 4);
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
. . . . . F X . . . . . . . . . . . . .
. . . . . F X X X X . . . . . . . . . .
. . . . . F X X X X X X X X . . . . . .
. . . . . . . X X X X X X X X X X . . .
. . . . . . . . . . X X X X X X X X X .
. Y Y Y Y . . . . . . . . . X X X X X .
. . Y Y Y Y . . . . . . . . . . . X X .
. . . Y Y Y Y . . . . . . . . . . . . .
. . . Y Y Y Y . . . . . . . . . . . . .
. . . . Y Y Y Y . . . . . . . . . . . .
. . . . . Y Y Y Y . . . . . . . . . . .
. . . . . . Y Y Y Y . . . . . . . . . .
. . . . . . Y Y Y Y . . . . . . . . . .
. . . . . . . Y Y Y Y . . . . . . . . .
. . . . . . . . F F F F . . . . . . . .
. . . . . . . . . . . . . . . . . . . .
*/

/* Окружность. Мы будем рисовать один сектор (x>=0, x<=y), а затем
размножеть его  на 8 секторов, используя следующую функцию.
Для наглядности выделяю "оригинальный" сегмент.
*/

inline void set8p(int xc, int yc, int x, int y){
    if ((x==0)&&(y==0)){
      paint(xc,yc,'C');
      return;
    }
    paint(xc+x,yc+y,'X');
    paint(xc+y,yc-x,'*');
    paint(xc-y,yc+x,'*');
    paint(xc-x,yc-y,'*');
    /* границы рисуем только у половины секторов, чтоб */
    /* не закрашивать дважды одну точку */
    if ((x>0)&&(x<y)){ 
      paint(xc+x,yc-y,'o');
      paint(xc+y,yc+x,'o');
      paint(xc-x,yc+y,'o');
      paint(xc-y,yc-x,'o');
    }
}

/*

Для некоторой точки окружности x,y (начало координат в центре
окружности) правильное направление - касательная к окружности, то есть
вектор (y,x). При шаге на +1 по оси x отклонение от правильного
направления увеличивается на x/y. При шаге на -1 по оси y отклонение
от правильного направления уменьшается на 1. Шаг по y надо делать,
если отклонение при шаге по x превысит 1/2.

В целых числах: шагаем по оси x, добавляя на каждом шаге к отклонению
e величину 2*x. Если при таком добавлении получается величина большая 
y, то сдалаем шаг по y и вычтем из отклонения 2*y.

Очень похоже на рисовании линии:
*/

void circ1(int xc, int yc, int r){
  int x = 0, y = r;
  int e = 0;

  set8p(xc, yc, x, y);
  while (x != y){
    if (e+2*x < y){
      x++;
      e+=2*x;
      set8p(xc, yc, x, y);
    }
    else {
      y--;
      e-=2*y;
    }
  }
}

/*
Опять оптимизации:
- в условии "e+2*x < y" граничное значение e меняется с каждым шагом
по x на -2, а с каждым шагом по y на +1.
В начальный момент величина этого граничного значения равна r.
Положим в начале e=-r, на каждом шагу будем добавлять +1 или убавлять
-2, а сравнивать будем с 0.
- заменим умножение на 2 сдвигом.
*/

void circ2(int xc, int yc, int r){
  int x = 0, y = r;
  int e = -r;

  set8p(xc, yc, x, y);
  while (x != y){
    if (e < 0){
      x++;
      e+=(x+1)<<2;
      set8p(xc, yc, x, y);
    }
    else {
      y--;
      e-=(y<<2)-1;
    }
  }
}

/*
  circ2(12,12,3);
  circ2(10,10,9);
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . 4 4 4 5 5 . . . . . . .
. . . . . . 4 4 . . . . . 5 5 . . . . .
. . . . . 4 . . . . . . . . . 5 . . . .
. . . . 4 . . . . . . . . . . . 2 . . .
. . . 8 . . . . . . . . . . . . . 2 . .
. . 8 . . . . . . . . . . . . . . . 2 .
. . 8 . . . . . . . . . . . . . . . 2 .
. 8 . . . . . . . . . . . . . . . . . 2
. 8 . . . . . . . . . 4 4 5 . . . . . 2
. 3 . . . . . . . . 4 . . . 2 . . . . 2
. 3 . . . . . . . 8 . . . . . 2 . . . 6
. 3 . . . . . . . 3 . . . . . 2 . . . 6
. . 3 . . . . . . 3 . . . . . 6 . . 6 .
. . 3 . . . . . . . 3 . . . 1 . . . 6 .
. . . 3 . . . . . . . 7 1 1 . . . 6 . .
. . . . 3 . . . . . . . . . . . 1 . . .
. . . . . 7 . . . . . . . . . 1 . . . .
. . . . . . 7 7 . . . . . 1 1 . . . . .
. . . . . . . . 7 7 1 1 1 . . . . . . .
*/


/*
Толстая окружность, закрашенная окружность. Вместо одной точки (x0,y0)
рисуем полоски от y=[y0..max(x0-1, y0-w)) и y=[max(x0-1, y0-w)..x0]
*/

inline void draw_line(int xc, int yc, int x0, int y0, int w, int fill){
  int y;
  int b=(x0-1>y0-w)? x0-1 : y0-w;

  for (y=y0; y>b; y--)
    set8p(xc, yc, x0, y);
  if (fill)
    for (y=b; y>=x0; y--)
      set8p(xc, yc, x0, y);
}

void circ3(int xc, int yc, int r, int w, int fill){
  int x = 0, y = r;
  int e = -r;
  if (w>r) w=r;

  draw_line(xc,yc,x,y,w,fill);
  while (x != y){
    if (e < 0){
      x++;
      e+=(x+1)<<2;
      draw_line(xc,yc,x,y,w,fill);
    }
    else {
      y--;
      e-=(y<<2)-1;
    }
  }
}


/*
  circ3(11,10,3, 1,1);
  circ3(10,10,9, 3,0);
. . . . . . . . . . . . . . . . . . . .
. . . . . . . . * * * o o . . . . . . .
. . . . . . * * * * * o o o o . . . . .
. . . . . * * * * * * o o o o o . . . .
. . . . * * * * . . . . . o o o * . . .
. . . o o * . . . . . . . . . * * * . .
. . o o o . . . . . . . . . . . * * * .
. . o o o . . . . . * * o . . . * * * .
. o o o . . . . . * * * o * . . . * * *
. o o o . . . . o o * * * * * . . * * *
. * * * . . . . * * * C * * * . . * * *
. * * * . . . . * * * X X o o . . o o o
. * * * . . . . . * o X X X . . . o o o
. . * * * . . . . . o X X . . . o o o .
. . * * * . . . . . . . . . . . o o o .
. . . * * * . . . . . . . . . X o o . .
. . . . * o o o . . . . . X X X X . . .
. . . . . o o o o o X X X X X X . . . .
. . . . . . o o o o X X X X X . . . . .
. . . . . . . . o o X X X . . . . . . .
*/

/*
Ну и испытываю все эти функции, чтобы получить картинки,
приведенные выше:
*/


void data_init(void){
  int i,j;
  for (j=0;j<MAXY;j++) for (i=0;i<MAXX;i++) paint(i,j,'.');
}
void data_print(void){
  int i,j;
  for (j=0;j<MAXY;j++)
    for (i=0;i<MAXX;i++)
      printf("%c%c", data[i][j], i==MAXX-1?'\n':' ');
  printf("\n");
}

main(){
  data_init();
  line1(1,1,17,13);
  data_print();

  data_init();
  line3(1,1,17,11);
  line3(1,4,7,18);
  data_print();

  data_init();
  line4(7,5,5,1);
  line4(5,5,1,3);
  line4(18,1,2,11);
  line4(18,4,6,18);
  data_print();

  data_init();
  line5(5,5,18,9, 3);
  line5(10,18,3,9, 4);
  data_print();

  data_init();
  circ2(12,12,3);
  circ2(10,10,9);
  data_print();

  data_init();
  circ3(11,10,3, 1,1);
  circ3(10,10,9, 3,0);
  data_print();

  data_init();
  circ3(10,10,8, 8,0);
  data_print();

  return 0;
}


